#!/usr/bin/env python3


"""
"""
import time
import glob
import pathlib
import shutil
import os

import lxml.etree

from suds.client import Client
from suds.cache import ObjectCache

import xmlschema


class SSTClient:
    '''Main automatic client for delivering data generated by the EISCAT 3D SST Services.

    :param logger logger: A logger instance, all calls to the application from the simple_server will be logged to this instance.
    :param configparser.ConfigParser config: The server configuration.
    :param bool delivery_log: If :code:`True` a internal list is kept of all files/data that has been delivered, can be considered a intentional memory leak and should only be used for testing.
    '''
    def __init__(self, config, logger, delivery_log=False):
        self.logger = logger
        self.config = config
        self.delivery_log = delivery_log
        self.deliveries = []

        self._dry_run = False

        inbox = config.get('SST Client', 'Inbox')
        inbox = pathlib.Path(inbox).absolute()

        self.inbox = inbox
        self.logger.debug(f'SSTClient: inbox={self.inbox}')

        archive = self.config.get('SST Client', 'Archive')
        archive = pathlib.Path(archive).absolute()

        self.archive = archive
        self.logger.debug(f'SSTClient: archive={self.archive}')

        self.file_ext = self.config.get('SST Client', 'File-extensions').split(',')
        self.file_ext = [x.strip() for x in self.file_ext]
        self.logger.debug(f'SSTClient: file extensions={self.file_ext}')



    def run(self):
        self.logger.info('SSTClient: STARTED')
        self.__run = True

        client = Client(
            'http://localhost:8009/ESA_CORE/SSTDataProcessingService/SSTDataProcessingService.wsdl',
            location='http://localhost:8009/ESA_CORE/SSTDataProcessingService/SSTDataProcessingService',
            cache=None,
        )

        while self.__run:
            self.logger.debug('SSTClient: looking for new tracklets to deliver')

            files = []
            for ext in self.file_ext:
                files += self.inbox.glob(f'**/*.{ext}')

            files = [pathlib.Path(file) for file in files]

            self.logger.info(f'SSTClient: {len(files)} files found, delivering')

            for file in files:
                with open(file, 'r') as r:
                    xml_data = r.read()
                
                method = client.wsdl.services[0].ports[0].methods['submitObservationData']
                message = method.binding.input.get_message(method, [], {})

                ns_req = '{http://esa.ssa/dpc/2.1/SubmitObservationDataRequestType}'
                ns_CCSDS = '{urn:ccsds:recommendation:navigation:schema:ndmxml}'
                ns_eCCSDS = '{http://esa.ssa.sst/2.1/CCSDS/}'

                NSMAP = {
                    'tns': ns_req[1:-1],
                    'CCSDS': ns_CCSDS[1:-1],
                    'eCCSDS': ns_eCCSDS[1:-1],
                }

                dont_ns = [
                    'CREATION_DATE',
                    'ORIGINATOR',
                    'TIME_SYSTEM',
                    'PARTICIPANT_1',
                    'PARTICIPANT_2',
                    'PARTICIPANT_3',
                    'START_TIME',
                    'STOP_TIME',
                    'MODE',
                    'PATH',
                    'TRANSMIT_BAND',
                    'RECEIVE_BAND',
                    'TIMETAG_REF',
                    'INTEGRATION_INTERVAL',
                    'INTEGRATION_REF',
                    'RANGE_UNITS',
                ]
                delte_tags = [
                    'MESSAGE_ID',
                    'COMMENT',
                ]

                tdm = lxml.etree.XML(xml_data.encode())

                for tag in tdm.iter():
                    if tag.tag in delte_tags:
                        tag.getparent().remove(tag)
                        continue
                    if tag.tag not in dont_ns:
                        tag.tag = f'{ns_eCCSDS}{tag.tag}'

                message = lxml.etree.XML(str(message).encode())

                measure = message.findall(f'.//{ns_req}measure')[0]

                measures = lxml.etree.Element(f'{ns_req}measures', nsmap = NSMAP)
                measures.attrib[f'{ns_eCCSDS}id'] = 'CCSDS_TDM_VERS'
                measures.attrib[f'{ns_eCCSDS}version'] = '2.0'
                measure.append(measures)
                
                for el in tdm:
                    measures.append(el)

                out = client.service.submitObservationData(__inject={'msg': lxml.etree.tostring(message, pretty_print=True)})

                if out:
                    if not self._dry_run:
                        shutil.move(file, self.archive / file.name)
                    self.logger.info(f'SSTClient: Delivery completed {file.name}\n Response="{out}"')
                    if self.delivery_log:
                        self.deliveries += [file]
                else:
                    self.logger.info(f'SSTClient: Delivery failed {file.name}\n Response="{out}"')

            time.sleep(self.config.getfloat('SST Client', 'Deliver interval'))


    def stop(self):
        self.__run = False
        self.logger.info('SST Client: STOPPED')


if __name__ == '__main__':
    from config import config as cfg
    import logging

    client = SSTClient(cfg, logging)
    client._dry_run = True

    client.run()